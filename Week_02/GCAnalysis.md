![Image text](https://github.com/MarcusJiang1306/JAVA-000/blob/main/Week_02/src/main/resources/gc%E6%A1%88%E4%BE%8B.png)
## gc日志分析
以上图表是基于GCLogAnalysis的分析结果，最上面的是老师的原版，1是在原有的基础上运行十秒，2是在10秒的基础上有随机休眠以降低对象的生成速度。后面会提到为什么会有三组案例。  
三组实验总体表现趋同，Parallel和G1表现出了较好的吞吐性能。Serial随着堆大小越来越大，单次gc时间也在加长，造成吞吐量下降，响应时间变长。值得一提的是CMS，在1g的堆以上吞吐量开始下降，我便开始尝试对CMS的日志进行分析  
因为1秒钟的程序可观察的东西实在是太少，我增加了一组10秒的测试和可以减缓生成速度sleep方案  
通过分析CMS的1g的log发现很容易触发concurrent mode failure，再使用GCEasy分析了1g和2g的log发现内存分配模式和并行gc不一样，在2g的时候新生代和survivor区远小于并行gc的，加上GCLogAnalysis生成对象的速度非常快，survivor在无法存放那么多对象的情况下强制把对象晋升到了老年代，从而导致了两个情况：新生代的gc非常频繁和单次young gc平均时间变长（推测强制晋升到老年代需要更多时间）。最直观反映到GCEasy的分析就是总的停顿时间变长了，且主要时间消耗在young gc。  
针对此案例我尝试强制将-XX:SurvivorRatio 和-XX:NewRatio设置得和并行gc差不多，在各内存分区大致相同的情况晋升速度明显慢了下来，young gc总时间得到了控制，吞吐量也有所提升（多次测试）  
在写本分析的时候我发现1g到4g的CMS的新生代分配都是固定的，应该是基于宿主机内存的多少份之一和最低下限设定的，应该是有意控制新生代大小。也就是说CMS对对象的生成速率以及宿主机核心/线程数都比较敏感，若线程数较少或对象生成速度较快的时候不适合CMS和应该选用G1和并行GC  
在分析CMS的表现的时候通过和助教的交流发现在jdk14之后，CMS已经被移除，我也纠结还要不要写本次分析，但最终觉得这是我对gc行为的观察的个人见解，有必要拿出来讨论是否理解上有偏差。  

## 测试方法
因为手动写参数太麻烦我又写了个简化版的java命令 （在script下的myjar和jarByBatch）（因为没Python环境和不会写Python - -）
