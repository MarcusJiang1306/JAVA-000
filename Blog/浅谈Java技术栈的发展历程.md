### 引言
在我4年前刚接触编程的时候学习的第一个语言是js，再之后2年前因为工作原因学习的是Java。因为那时候都是去w3c或者是没有反馈的学习平台学习这些知识点，会有我学了这些知识能干嘛？可以创造些什么东西的困惑。还记得后来在上一次线下培训班的时候，老师说过我们学一个编程语言一定要知道他的特性擅长于什么方面，而不是手拿一个锤子看什么都是钉子，然而在那次学习完成后我依旧没有找到这个答案。

其实就单从Java这门语言来说，如果有玩Minecraft的小伙伴可能知道，其中一个版本就是Java写的，所以Java语言是个多面手。但支撑Java飞速发展，长期霸榜在编程语言流行榜的其实是在互联网项目中被大量应用，也就是大家常说的Java Web。在这个世界，Java提供了对外能展示/接收数据的能力（前期甚至能显示页面，即jsp），内部能根据数据进行相对应的处理和转化，最后能连接到支持Sql/NoSql的数据存储平台将数据持久化。简单来说，Java在客户端和数据库之间搭起了一座桥梁，使得人们在网络上所有行为都能被记录下来。

### 软件架构的发展
在聊各种各样的技术栈之前，我认为有必要先讨论项目的架构发展历程，架构的发展和技术栈的出现是相辅相成的。正因为有新的需求出现和流量越来越大，在架构上寻求改变创造出了各种各样的技术，在实际使用中根据技术的实践调整着架构的后续发展。

在单体架构怎么发展到微服务，其中经历了什么，对于我这样的新人也许是找不到答案了。但从架构的演变，总结出其特性，再看其中用到的技术，也许我们能管中窥豹了解到这些技术栈在其中的作用是什么。

在最早的单体架构，能查找到的资料已经相对较少了，但根据某个大课的介绍当中还是能可见一斑。由于当时处于初步发展阶段，没有框架的引入，许多的实现只有标准没有统一，功能的复用性差，代码可阅读性差进一步导致可维护性变差。

在经历了混沌之初之后，逐渐的从设计模式中吸收经验，提炼出了通用模块和设计模式。对项目进行垂直分层，最经典的说法就是MVC，区分出了模型层，控制层和视图层，同时每一层都有对应的框架作为支持，降低了类似项目的开发周期并加强了阅读性，这就是Spring一系列技术栈乃至SSH/SSM的起源。同时运用Nginx/F5等反向代理技术进行负载均衡。

但单机的性能终究是有限的，一个所有服务放在一个项目里头的聚合怪，职责不明确。需要将各类服务细化管理，所以需要进行一系列的改造。  
1. 前后端分离
2. 将单独可对外提供服务分离出来。
3. 对应的数据库分离开来降低读写和存储的压力
4. 同时通过缓存技术将热点数据及时返回降低数据库压力
5. 通过MQ和RPC技术对其他服务进行调用
6. 通过Shardingsphere之类的技术对数据库进行分库分表进一步提升读写能力。

随着服务分离的发展也衍生出了服务注册与发现，负载均衡，高可用，熔断降级，服务追踪和可观测性等一系列服务治理手段，统一的业务网关进行鉴权、流控的处理。同时因为服务治理的技术能支撑起更多服务的管理，从而可以拆分出更细粒度的服务，然后通过RPC或者是MQ的方式去调用。

后来随着docker技术的出现，如何在云平台进行服务的有效管理，弹性伸缩，容器编排等技术让服务能在短时间内迅速扩容来应对海量的访问。

从整个演化过程看来，就像是人类社会的发展，从一手包办到分工合作，到协同工作，Java服务的架构演化也殊途同归，从单体架构到SOA，通过RPC/MQ等技术进行沟通，到微服务，有一套统一的管理方法将服务管理起来。

由于目前对整个架构的演进的认识还是不足，不过也足够我们从中能体会到整个生态大体是什么样子了。

### 各技术栈浅析

- jdk & jvm

千里之行始于足下，既然我们学习Java web的项目，首先肯定是要对Java本身要熟悉，除了随便找个网课都有的入门，其实最关键的是jvm内存模型、诊断和调优，这是让Java程序健康运作的基石；类加载器，能让我们控制运行中jar包的装卸和重复定义的能力；字节码技术更是aop和rpc的关键技术。有余力的还可以了解一些其他的运行在jvm的语言，如Groovy、Scala等

- 多线程

随着技术的发展，硬件厂商选择单机多核多线程的方式来提升计算机的性能，这就要求程序拥有多线程优化的能力，除去Java程序来说，我们能玩到的游戏，是否支持多线程运算效率是天差地别。  
在Java当中多线程技术主要体现几个方面：
1. 在线程之间的协作，互相之间的等待与唤醒
2. 各种锁：synchronized和显式Lock，
3. 线程间协作信号量：CountDownLatch/CyclicBarrier/Semaphore
4. 原子操作类（基于compare and swap 即CAS）
5. 线程管理：Executor，Future，Runnable/Callable
6. 并发集合类：CopyOnWriteArrayList/CopyOnWriteMap

其总结下来就是尽量将写和读之间的冲突进行管理，使得数据在同一个时刻是正确的。

- NIO

当一个服务通过网络调用另外服务的时候，在BIO的模型下，通道不能复用，且会阻塞线程，资源得不到释放但却无法有效工作，这时候就需要NIO把线程腾出来，达到一个线程并发处理多个事件的能力。在Java的世界中虽然有原生的NIO库，但直接使用上手难度大，所以默认讲到NIO会提到netty。netty对NIO进行了封装使得两个应用之间的通信十分便捷，唯一对新手不太友好的是对信息的处理是可高度定制化的，所以各种信息的handler和netty的各种模型以及调优是学习netty的关键。

- Spring全家桶

Spring和别的技术不一样，他不直接参与到业务中来，从最原始的IOC和AOP功能来看他优化了程序的设计，让类与类之间的关系做一定的解耦。到后来他包办了从前端页面的绑定到各种数据库/mq/等外部服务的对接，整个体系变得十分复杂。直到他们推出了Springboot，通过约定大于配置的方式极大的简化了服务的配置流程，可以说Springboot、与其整合的各种ORM框架，各种服务的Client端，使得服务更加简单和纯粹，开发者能更专注在业务上而不是陷入配置地狱和环境地狱上。

- 数据库

在前面说到，我们能接触到的大部分互联网服务本质都是前端接收数据，经过处理之后持久化到硬盘，数据库就是其中一个很重要的载体。同时也意味着即便整个程序都能做到无状态化，但到了数据库这里，他是记录状态的，这样就有了高并发下数据访问的问题。如何保证数据是一直稳定可访问的，数据存放和访问高效率/高可用的方式无非就是那三板斧，通过从查询端优化查询方式降低单次crud占用时间，降低锁占用范围和时间，以求单机读写性能最大化；一个数据源不稳定我们上主从，主从需要切换我们弄一个自动Failover机制；同类数据一个库装不下我们分片存放再统一访问；这些技术体现在MySQL就是MySQL的主从复制、MHA（MySQL High Available）和MGR（MySQL Group Replication）来实现自动的自从切换；数据分库分表则体现在以Shardingsphere为首的一类中间件提供的一整套分库分表解决方案。

- 缓存技术

缓存技术可以说是降低数据库压力的第一板斧，借用头文字D（电影版）一句名台词，压力来自于IO。网络IO大家都要互相调用，基于tcp长连接的方式基本已经做了大量优化，但磁盘IO相比起来，耗时就大得多，如果在读写比非常悬殊的热点数据，埋伏他一手，直接在缓存里拿出来，岂不美哉？其实这就像你收藏了一大堆书签，能排在前面的永远是你最高频访问的。而缓存技术又分为本地缓存和远端缓存，在量小的情况且无分布式场景的情况下本地缓存使用简单，无需外挂。但一旦遇到分布式场景的情况下本地缓存涉及缓存同步的问题，所以一般使用远端的缓存服务，一般是Redis，在笔者看来Redis能看成一个异化的轻量级的数据库，所以上文所述的主从/分片/cluster一应俱全，但因为主要存的是非结构化数据，在使用的时候需要注意数据的存放方式和最大化利用缓存空间，毕竟内存的资源绝大部分时候比磁盘要宝贵得多嘛。

- RPC技术

RPC（Remote Procedure Call）远程过程调用，通俗说法就是：通过两个服务之间保留存根的方式来达到近似“像调用本地方法一样调用远程方法”的效果，广义来说其本质意义就是实现了进程与进程之间的通信，使其能合作完成一些业务上的操作。但如果从进程间的通信的角度来看，其实可以是协议无关（无论tcp还是HTTP还是自定义协议），甚至不限定连接方式，基于文件、内存、数据库都可以，概括的说只要双方通过一定的媒介交换到了信息，它们之间就完成了通信。但为什么还要单独聊RPC呢？我认为有几点原因，首先他可以做到足够简单，尤其是在同一类系统当中，例如都是java的系统；因为足够简单，我们可以比较方便的在上面添加增强的功能，例如服务注册与发现，负载均衡，熔断限流，链路跟踪。正是因为一整套的服务治理的手段，赋予了RPC新的意义。

- MQ技术

和RPC技术同样的是，MQ也是起到了进程间通信的作用，同时和RPC相比能有效降低服务之间的拓扑结构的复杂程度。不过如果仅仅只有降低拓扑结构的复杂程度不足以让MQ如此火热。和数据库/缓存针对结果进行处理不一样的是，MQ主要负责对请求的储存，能够储存消息的MQ获得了类似抽水蓄能电站的能力，调节着下游服务的请求接收量，使得系统处于相对稳定的状态。

### 总结

以上因为个人的知识浅薄，讲到的只是各技术栈的冰山一角，但从以上各种技术的特点来看，其最终目的都是围绕着如何更快的处理请求，接收更多种类的数据，接收更多的请求。同时我们也应该学会思考，新的技术是如何提升这些点的性能指标，运用新技术需要付出的努力和收益是否成正比，来初步判断技术的前景性。



























